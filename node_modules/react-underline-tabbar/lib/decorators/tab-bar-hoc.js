'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

exports.default = ScrollPageHOC;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('../prop-types');

var _utils = require('../utils');

var _components = require('../components');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function ScrollPageHOC(WrappedComponent) {
  var _class, _temp, _initialiseProps;

  return _temp = _class = function (_WrappedComponent) {
    _inherits(TabBarHOC, _WrappedComponent);

    function TabBarHOC(props) {
      _classCallCheck(this, TabBarHOC);

      var _this = _possibleConstructorReturn(this, (TabBarHOC.__proto__ || Object.getPrototypeOf(TabBarHOC)).call(this, props));

      _initialiseProps.call(_this);

      var activeTab = props.activeTab,
          pos = props.pos;


      var scrollValue = new _components.Animated.Value(activeTab);
      _this.state = {
        scrollValue: scrollValue
      };

      _this.tabState = {};
      _this.tabStateDone = false;
      _this.initialSetupWasDone = false;
      _this.isScrollTabBar = null;
      _this._isOnPress = false;

      _this.widthCollection = null;
      _this.offsetCollection = null;
      _this.scrollOffsetsCollection = null;

      _this.containerLayout = null;
      _this.scrollViewLayout = null;

      // 是否传入动画值，传入此值可借此监听做同步动画
      _this.hasPos = !!pos;
      if (pos) {
        var isAnimated = pos instanceof _components.Animated.Value;
        if (!isAnimated) {
          console.warn('pos is not instanceof Animated');
          _this.hasPos = false;
        }
      }
      return _this;
    }

    _createClass(TabBarHOC, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _this2 = this;

        var _props = this.props,
            hasAnimation = _props.hasAnimation,
            pos = _props.pos,
            isTest = _props.isTest;


        if (hasAnimation) {
          var scrollValue = this.state.scrollValue;
          // 未传入动画值则使用自己的动画值做监听

          var animatedValue = this.hasPos ? pos : scrollValue;
          animatedValue.addListener(function () {
            var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var defaultWidth = (0, _utils.get)(_this2.containerLayout, 'width');
            var defaultHeight = (0, _utils.get)(_this2.containerLayout, 'height');
            var _props2 = _this2.props,
                _props2$width = _props2.width,
                width = _props2$width === undefined ? defaultWidth : _props2$width,
                _props2$height = _props2.height,
                height = _props2$height === undefined ? defaultHeight : _props2$height,
                vertical = _props2.vertical;

            var propsValue = vertical ? height : width;
            if (propsValue) {
              var value = _this2.hasPos ? params.value / propsValue : params.value;
              _this2.handleScrolling({ value: value });
            }
          });
        }
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var _props3 = this.props,
            activeTab = _props3.activeTab,
            hasAnimation = _props3.hasAnimation;

        var nextActiveTab = nextProps.activeTab;

        if (!this._isOnPress && activeTab !== nextActiveTab) {
          if (hasAnimation) {
            if (!this.hasPos) {
              this._updateAnimated(nextActiveTab);
            }
          } else {
            this.handleScrolling({ value: nextActiveTab });
          }
        }
      }
    }, {
      key: '_checkCount',
      value: function _checkCount() {
        var tabs = this.props.tabs;

        var currentTabsLen = (0, _utils.size)(tabs);
        this._tempCount += 1;

        if (this._tempCount >= currentTabsLen) {
          this._tempCount = 0;
          this.tabStateDone = true;
        } else {
          this.tabStateDone = false;
        }
      }
    }, {
      key: 'onTabLayout',
      value: function onTabLayout(_ref, page) {
        var nativeEvent = _ref.nativeEvent;
        var _nativeEvent$layout = nativeEvent.layout,
            x = _nativeEvent$layout.x,
            y = _nativeEvent$layout.y,
            width = _nativeEvent$layout.width,
            height = _nativeEvent$layout.height;

        var tabValue = { x: x, y: y, width: width, height: height };
        var isUpdate = !(0, _utils.isEqual)((0, _utils.get)(this.tabState, page, {}), tabValue);

        this.tabState[page] = { x: x, y: y, width: width, height: height };
        if (isUpdate) {
          this._checkCount(page);
        }
        this.checkMeasures(isUpdate);
      }
    }, {
      key: 'applyTransformToUnderline',
      value: function applyTransformToUnderline(scaleValue, dPos) {
        var _style;

        if (!this.underlineRef) return;
        var _props4 = this.props,
            vertical = _props4.vertical,
            _props4$underlineStyl = _props4.underlineStyle,
            underlineStyle = _props4$underlineStyl === undefined ? {} : _props4$underlineStyl,
            _props4$isAutoSize = _props4.isAutoSize,
            isAutoSize = _props4$isAutoSize === undefined ? false : _props4$isAutoSize;

        // const matrix = createTranslateXScaleX(scaleValue, dPos)
        // transformOrigin(matrix, { x: -0.5, y: 0, z: 0 })

        var valueKey = vertical ? 'height' : 'width';
        var posKey = vertical ? 'translateY' : 'translateX';
        var fixedSize = (0, _utils.get)(underlineStyle, valueKey);
        var sizeValue = scaleValue;
        var posValue = dPos;
        // 固定尺寸
        var isReplace = isAutoSize ? !this.isScrollTabBar : true;
        if (isReplace && fixedSize && fixedSize < scaleValue) {
          sizeValue = fixedSize;
          var diffValue = (scaleValue - fixedSize) / 2;
          posValue = dPos + diffValue;
        }

        this.underlineRef.setNativeProps({
          style: (_style = {}, _defineProperty(_style, valueKey, sizeValue), _defineProperty(_style, 'transform', [_defineProperty({}, posKey, posValue)]), _style)
        });
      }
    }, {
      key: 'renderUnderline',
      value: function renderUnderline(style) {
        var hasUnderline = this.props.hasUnderline;

        if (!hasUnderline) return null;

        return _react2.default.createElement(_components.AnimatedView, { ref: this._setUnderlineRef, style: style });
      }
    }, {
      key: '_updateAnimated',
      value: function _updateAnimated(toValue, callBack) {
        var duration = this.props.duration;
        var scrollValue = this.state.scrollValue;

        var easing = _components.Easing.out(_components.Easing.ease);

        _components.Animated.timing(scrollValue, { toValue: toValue, duration: duration, easing: easing }).start(callBack);
      }
    }, {
      key: '_getStyle',
      value: function _getStyle(isClearCache) {
        if (isClearCache) this.Style = null;
        if (this.Style) return this.Style;

        var _props5 = this.props,
            style = _props5.style,
            scrollViewStyle = _props5.scrollViewStyle,
            underlineStyle = _props5.underlineStyle,
            tabStyle = _props5.tabStyle,
            tabActiveStyle = _props5.tabActiveStyle,
            tabTextStyle = _props5.tabTextStyle,
            tabTextActiveStyle = _props5.tabTextActiveStyle,
            vertical = _props5.vertical;


        var baseStyles = (0, _utils.getMergeObject)(defaultStyle, {
          containerStyle: style,
          scrollViewStyle: scrollViewStyle,
          underlineStyle: underlineStyle,
          tabStyle: tabStyle,
          tabActiveStyle: tabActiveStyle,
          tabTextStyle: tabTextStyle,
          tabTextActiveStyle: tabTextActiveStyle
        });

        var commonStyles = (0, _utils.getMergeObject)(baseStyles, getCommonStyle({ vertical: vertical }));
        var mergeStyles = (0, _utils.getMergeObject)(commonStyles, _components.Style);
        this.Style = (0, _utils.getMergeObject)(mergeStyles, _get(TabBarHOC.prototype.__proto__ || Object.getPrototypeOf(TabBarHOC.prototype), '_getStyle', this).call(this));

        return this.Style;
      }
    }, {
      key: 'render',
      value: function render() {
        var _props6 = this.props,
            tabs = _props6.tabs,
            vertical = _props6.vertical,
            scrollEnabled = _props6.scrollEnabled;

        var _getStyle2 = this._getStyle(true),
            containerStyle = _getStyle2.containerStyle,
            scrollViewStyle = _getStyle2.scrollViewStyle,
            underlineStyle = _getStyle2.underlineStyle;

        return _react2.default.createElement(
          _components.View,
          {
            style: containerStyle,
            onLayout: this._onContainerLayout
          },
          _react2.default.createElement(
            _components.ScrollView,
            {
              style: scrollViewStyle,
              onRef: this._scrollViewRef,
              onContentSizeChange: this._onContentSizeChange,
              scrollEnabled: scrollEnabled,
              onScroll: this._onScroll,
              vertical: vertical
            },
            tabs.map(this.renderTab),
            this.renderUnderline(underlineStyle)
          )
        );
      }
    }]);

    return TabBarHOC;
  }(WrappedComponent), _class.defaultProps = _propTypes.defaultProps, _class.propTypes = _propTypes.propTypes, _initialiseProps = function _initialiseProps() {
    var _this3 = this;

    this._scrollViewRef = function (node) {
      _this3.scrollView = node;
    };

    this._setUnderlineRef = function (ref) {
      _this3.underlineRef = ref;
    };

    this._onContainerLayout = function (_ref3) {
      var nativeEvent = _ref3.nativeEvent;

      _this3.containerLayout = nativeEvent.layout;
      _this3.checkMeasures();
    };

    this._onContentSizeChange = function (width, height) {
      var scrollViewValue = { x: 0, y: 0, width: width, height: height };
      var isUpdate = !(0, _utils.isEqual)(_this3.scrollViewLayout || {}, scrollViewValue);

      _this3.scrollViewLayout = scrollViewValue;
      _this3.checkMeasures(isUpdate);
    };

    this._tempCount = 0;

    this.checkMeasures = function (isUpdate) {
      var tabs = _this3.props.tabs;

      var currentTabsLen = (0, _utils.size)(tabs);
      // const isGtMinLimit = currentTabsLen > 1
      var tabStateDone = currentTabsLen === (0, _utils.size)((0, _utils.keys)(_this3.tabState));

      // if (isGtMinLimit && this.containerLayout && this.scrollViewLayout && tabStateDone) {
      if (_this3.containerLayout && _this3.scrollViewLayout && tabStateDone) {
        // 滚动尺寸发生变化时更新动画映射值
        if (!_this3.initialSetupWasDone || isUpdate) {
          _this3.calculateInterpolations();
        }

        if (!_this3.initialSetupWasDone || _this3.tabStateDone) {
          _this3.initialSetupWasDone = true;
          _this3.tabStateDone = false;
          var activeTab = _this3.props.activeTab;


          _this3.handleScrolling({ value: activeTab });
          _this3.forceUpdate();
        }
      }
    };

    this.handleScrolling = function (_ref4) {
      var value = _ref4.value;

      var dPos = (0, _utils.get)(_this3.offsetCollection, '_interpolation', function () {
        return 0;
      })(value);
      var scaleValue = (0, _utils.get)(_this3.widthCollection, '_interpolation', function () {
        return 0;
      })(value);

      _this3.applyTransformToUnderline(scaleValue, dPos);
      if (_this3.scrollOffsetsCollection) {
        var scrollOffset = (0, _utils.get)(_this3.scrollOffsetsCollection, '_interpolation', function () {
          return 0;
        })(value);

        if (_this3.scrollView) {
          var _this3$scrollView$scr;

          var vertical = _this3.props.vertical;

          var key = vertical ? 'y' : 'x';

          _this3._scrollOffsetX = scrollOffset;
          _this3.scrollView.scrollTo((_this3$scrollView$scr = {}, _defineProperty(_this3$scrollView$scr, key, scrollOffset), _defineProperty(_this3$scrollView$scr, 'animated', false), _this3$scrollView$scr));
        }
      }
    };

    this.calculateInterpolations = function () {
      var inputRange = (0, _utils.keys)(_this3.tabState).map(Number);
      var len = (0, _utils.size)(inputRange);
      var outputRangePos = [];
      var outputRangeValue = [];
      var outputRangeScroll = [0];
      var scrollValue = _this3.state.scrollValue;
      var _props7 = _this3.props,
          scrollPosition = _props7.scrollPosition,
          vertical = _props7.vertical;

      var getKey = vertical ? 'height' : 'width';

      inputRange.forEach(function (key) {
        var _tabState$key = _this3.tabState[key],
            x = _tabState$key.x,
            y = _tabState$key.y,
            _tabState$key$width = _tabState$key.width,
            width = _tabState$key$width === undefined ? 0 : _tabState$key$width,
            _tabState$key$height = _tabState$key.height,
            height = _tabState$key$height === undefined ? 0 : _tabState$key$height;

        outputRangePos.push(vertical ? y : x);
        outputRangeValue.push(vertical ? height : width);
      });
      if (len < 2) {
        inputRange.push(1);
        outputRangePos.push(0);
        outputRangeValue.push(0);
      }
      _this3.offsetCollection = scrollValue.interpolate({
        inputRange: inputRange,
        outputRange: outputRangePos
      });
      _this3.widthCollection = scrollValue.interpolate({
        inputRange: inputRange,
        outputRange: outputRangeValue
      });

      var containerValue = (0, _utils.get)(_this3.containerLayout, getKey);
      var scrollViewValue = (0, _utils.get)(_this3.scrollViewLayout, getKey);
      var maxScrollOffset = scrollViewValue - containerValue;
      if (maxScrollOffset < 0) maxScrollOffset = 0;

      inputRange.forEach(function (key, index) {
        if (index === 0) return;

        var tabPos = outputRangePos[index];
        var tabValue = outputRangeValue[index];

        // const nextTabLeft = outputRangePos[index + 1] || scrollViewValue
        // 计算tab间的间距
        // const tabMargin = nextTabLeft - (tabPos + tabValue)
        // 默认定位到中间
        var scrollOffset = tabPos - containerValue / 2 + tabValue / 2;
        if (scrollPosition === 'prev') {
          var prevTabLeft = outputRangePos[index - 1];
          // const prevTabWidth = outputRangeValue[index - 1]

          scrollOffset = prevTabLeft;
        } else if (scrollPosition === 'next') {
          var nextTabLeft = outputRangePos[index + 1] || tabPos + tabValue;
          var nextTabValue = outputRangeValue[index + 1] || 0;
          var totalLength = nextTabLeft + nextTabValue;

          scrollOffset = totalLength - containerValue;
        }

        if (scrollOffset < 0) scrollOffset = 0;
        if (scrollOffset > maxScrollOffset) scrollOffset = maxScrollOffset;

        outputRangeScroll.push(scrollOffset);
      });

      if (scrollViewValue <= containerValue) {
        _this3.scrollOffsetsCollection = scrollValue.interpolate({
          inputRange: [-1, 0],
          outputRange: [-40, 0],
          extrapolate: 'clamp'
        });
      } else {
        _this3.scrollOffsetsCollection = scrollValue.interpolate({
          inputRange: [-1].concat(_toConsumableArray(inputRange)),
          outputRange: [-40].concat(outputRangeScroll)
        });
      }

      var tabTotalValue = outputRangeValue.reduce(function (count, value) {
        return count + value;
      }, 0);
      if (tabTotalValue > containerValue) {
        _this3.isScrollTabBar = true;
      } else {
        _this3.isScrollTabBar = false;
      }
    };

    this._onScroll = function (_ref5) {
      var nativeEvent = _ref5.nativeEvent;
      var contentOffset = nativeEvent.contentOffset;

      var _ref6 = contentOffset || {},
          x = _ref6.x,
          y = _ref6.y;

      _this3._scrollOffsetX = x;
      _this3._scrollOffsetY = y;
    };

    this._onPress = function (page, tab) {
      var _props8 = _this3.props,
          goToPage = _props8.goToPage,
          activeTab = _props8.activeTab,
          hasAnimation = _props8.hasAnimation;
      var scrollValue = _this3.state.scrollValue;

      if (page === activeTab) return;

      // this._direction = page > activeTab ? 'next' : 'prev'
      if (!_this3.hasPos && hasAnimation) {
        _this3._isOnPress = true;
        _this3._updateAnimated(page, function () {
          _this3._isOnPress = false;
        });
      } else {
        // 这里只是同步一下值，并没有元素消费这个动画值，只是在用这个值做映射
        scrollValue.setValue(page);
      }

      goToPage(page, tab);
    };

    this.renderTab = function (tab, page) {
      var _props9 = _this3.props,
          activeTab = _props9.activeTab,
          renderTab = _props9.renderTab;

      var isTabActive = activeTab === page;
      var onPress = function onPress() {
        return _this3._onPress(page, tab);
      };
      var onLayout = function onLayout(event) {
        return _this3.onTabLayout(event, page);
      };

      if (renderTab) {
        var element = renderTab({ tab: tab, page: page, onPress: onPress, onLayout: onLayout, isTabActive: isTabActive });
        return _react2.default.cloneElement(element, { onLayout: onLayout });
      }
      var label = tab.label;

      var _getStyle3 = _this3._getStyle(),
          tabStyle = _getStyle3.tabStyle,
          tabActiveStyle = _getStyle3.tabActiveStyle,
          tabTextStyle = _getStyle3.tabTextStyle,
          tabTextActiveStyle = _getStyle3.tabTextActiveStyle;

      return _react2.default.createElement(
        _components.Button,
        {
          style: (0, _utils.mergeStyle)(tabStyle, isTabActive ? tabActiveStyle : {}),
          key: page,
          onPress: onPress,
          onLayout: onLayout
        },
        _react2.default.createElement(
          _components.Text,
          {
            style: (0, _utils.mergeStyle)(tabTextStyle, isTabActive ? tabTextActiveStyle : {})
          },
          label
        )
      );
    };
  }, _temp;
}

var defaultStyle = {
  containerStyle: {
    borderTopWidth: 0,
    borderLeftWidth: 0,
    borderRightWidth: 0,
    borderBottomWidth: 0,
    borderColor: '#d2d2d2',
    borderStyle: 'solid'
  },
  tabTextActiveStyle: {
    color: 'navy'
  },
  underlineStyle: {
    backgroundColor: 'navy',
    height: 2,
    width: 2,
    bottom: 0,
    padding: 0
  },
  tabStyle: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    height: 50
  },
  scrollViewStyle: {
    justifyContent: 'space-between'
  }
};

var getCommonStyle = function getCommonStyle(_ref7) {
  var _underlineStyle;

  var vertical = _ref7.vertical;

  var borderWIdthKey = vertical ? 'borderRightWidth' : 'borderBottomWidth';
  var linePos = vertical ? 'top' : 'left';
  var lineSize = vertical ? 'height' : 'width';
  var flexDirection = vertical ? 'column' : 'row';

  return {
    containerStyle: _defineProperty({
      overflow: 'hidden',
      flexDirection: flexDirection,
      justifyContent: 'flex-start'
    }, borderWIdthKey, 1),
    underlineStyle: (_underlineStyle = {
      position: 'absolute'
    }, _defineProperty(_underlineStyle, linePos, 0), _defineProperty(_underlineStyle, lineSize, 0), _underlineStyle),
    scrollViewStyle: {
      flexDirection: flexDirection,
      position: 'relative'
    }
  };
};