{"ast":null,"code":"import axios from \"axios\";\nimport jwtDecode from \"jwt-decode\";\nimport setAuthorizationToken from \"../utils/setAuthorizationToken\";\nimport { SET_CURRENT_USER } from \"../helpers/types\";\n/*Axios instance를 통해 config 객체를 넘겨서  Axios instance를 넘기면\n헤더를 중복하여 정의해주지 않아도 된다.*/\n\nvar signInAxios = axios.create({\n  baseURL: \"https://a.chameleon4switch.cf/api\",\n  headers: {\n    \"Content-Type\": \"application/json\"\n  },\n  timeout: 5000\n});\nexport function signIn(email, password) {\n  return signInAxios.post(\"auth/signIn\", {\n    email: email,\n    password: password\n  }).then(function (res) {\n    console.log(res.data);\n    console.log(\"***************************\");\n    console.log(res.data.message);\n    console.log(\"***************************\");\n    var token = res.data.data.accessToken.token;\n    localStorage.setItem(\"jwtToken\", token);\n    setAuthorizationToken(token);\n    setCurrentUser(jwtDecode(token));\n    console.log(localStorage.getItem(\"jwtToken\"));\n    var email = res.data.data.userInfo.email;\n    var name = res.data.data.userInfo.name;\n    var nameEn = res.data.data.userInfo.name_en;\n    var profilImg = res.data.data.userInfo.profile_img;\n    localStorage.setItem(\"email\", email);\n    localStorage.setItem(\"name\", name);\n    localStorage.setItem(\"nameEn\", nameEn);\n    localStorage.setItem(\"profilImg\", profilImg);\n  });\n}\nexport function setCurrentUser(user) {\n  return {\n    type: SET_CURRENT_USER,\n    user: user\n  };\n}\nexport function logout() {\n  return function (dispatch) {\n    localStorage.removeItem(\"jwtToken\");\n    setAuthorizationToken(false);\n    setCurrentUser({});\n  };\n} // signInAxios.interceptors.response.use(\n//   function(response) {\n//     // If the request succeeds, we don't have to do anything and just return the response\n//     return response;\n//   },\n//   function(error) {\n//     const errorResponse = error.response;\n//     if (isTokenExpiredError(errorResponse)) {\n//       return resetTokenAndReattemptRequest(error);\n//     }\n//     // If the error is due to other reasons, we just throw it back to axios\n//     return Promise.reject(error);\n//   }\n// );\n// function isTokenExpiredError(errorResponse) {\n//   // Your own logic to determine if the error is due to JWT token expired returns a boolean value\n// }\n// let isAlreadyFetchingAccessToken = false;\n// // This is the list of waiting requests that will retry after the JWT refresh complete\n// let subscribers = [];\n// function resetTokenAndReattemptRequest(error) {\n//   try {\n//     const { response: errorResponse } = error;\n//     const resetToken = await TokenUtils.getResetToken(); // Your own mechanism to get the refresh token to refresh the JWT token\n//     if (!resetToken) {\n//       // We can't refresh, throw the error anyway\n//       return Promise.reject(error);\n//     }\n//     /* Proceed to the token refresh procedure\n//     We create a new Promise that will retry the request,\n//     clone all the request configuration from the failed\n//     request in the error object. */\n//     const retryOriginalRequest = new Promise(resolve => {\n//     /* We need to add the request retry to the queue\n//     since there another request that already attempt to\n//     refresh the token */\n//       addSubscriber(access_token => {\n//         errorResponse.config.headers.Authorization = 'Bearer ' + access_token;\n//         resolve(axios(errorResponse.config));\n//       });\n//     });\n//     if (!isAlreadyFetchingAccessToken) {\n//       isAlreadyFetchingAccessToken = true;\n//       const response = await axios({\n//         method: 'post',\n//         url: `<YOUR TOKEN REFREH ENDPOINT>`,\n//         data: {\n//           token: resetToken // Just an example, your case may vary\n//         }\n//       });\n//       if (!response.data) {\n//         return Promise.reject(error);\n//       }\n//       const newToken = response.data.token;\n//       TokenUtils.saveRefreshToken(newToken); // save the newly refreshed token for other requests to use\n//       isAlreadyFetchingAccessToken = false;\n//       onAccessTokenFetched(newToken);\n//     }\n//     return retryOriginalRequest;\n//   } catch (err) {\n//     return Promise.reject(err);\n//   }\n// }\n// function onAccessTokenFetched(access_token) {\n// \t// When the refresh is successful, we start retrying the requests one by one and empty the queue\n//   subscribers.forEach(callback => callback(access_token));\n//   subscribers = [];\n// }\n// function addSubscriber(callback) {\n//   subscribers.push(callback);\n// }\n// /////////////\n// export const login = (email, password) => {\n//   signInAxios\n//     .post(`/auth/signin`, { email, password })\n//     .then(res => {\n//       dispatch(loginSuccess(res.data, email));\n//       const token = res.data.token;\n//       axios.defaults.headers.common[\"Authorization\"] = token;\n//       history.pushState(\"/\");\n//     })\n//     .catch(err => {\n//       if (err.response.status === 401) {\n//         dispatch(loginFailure(err));\n//       }\n//     });\n// };","map":{"version":3,"sources":["C:/Users/o_ov0/Downloads/Front-End-develop/Front-End-develop/client/src/services/SignInService.js"],"names":["axios","jwtDecode","setAuthorizationToken","SET_CURRENT_USER","signInAxios","create","baseURL","headers","timeout","signIn","email","password","post","then","res","console","log","data","message","token","accessToken","localStorage","setItem","setCurrentUser","getItem","userInfo","name","nameEn","name_en","profilImg","profile_img","user","type","logout","dispatch","removeItem"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,SAAP,MAAsB,YAAtB;AACA,OAAOC,qBAAP,MAAkC,gCAAlC;AACA,SAASC,gBAAT,QAAiC,kBAAjC;AAEA;;;AAEA,IAAMC,WAAW,GAAGJ,KAAK,CAACK,MAAN,CAAa;AAC/BC,EAAAA,OAAO,EAAE,mCADsB;AAE/BC,EAAAA,OAAO,EAAE;AACP,oBAAgB;AADT,GAFsB;AAK/BC,EAAAA,OAAO,EAAE;AALsB,CAAb,CAApB;AAOA,OAAO,SAASC,MAAT,CAAgBC,KAAhB,EAAuBC,QAAvB,EAAiC;AACtC,SAAOP,WAAW,CAACQ,IAAZ,CAAiB,aAAjB,EAAgC;AAAEF,IAAAA,KAAK,EAALA,KAAF;AAASC,IAAAA,QAAQ,EAARA;AAAT,GAAhC,EAAqDE,IAArD,CAA0D,UAAAC,GAAG,EAAI;AACtEC,IAAAA,OAAO,CAACC,GAAR,CAAYF,GAAG,CAACG,IAAhB;AAEAF,IAAAA,OAAO,CAACC,GAAR,CAAY,6BAAZ;AACAD,IAAAA,OAAO,CAACC,GAAR,CAAYF,GAAG,CAACG,IAAJ,CAASC,OAArB;AACAH,IAAAA,OAAO,CAACC,GAAR,CAAY,6BAAZ;AAEA,QAAMG,KAAK,GAAGL,GAAG,CAACG,IAAJ,CAASA,IAAT,CAAcG,WAAd,CAA0BD,KAAxC;AACAE,IAAAA,YAAY,CAACC,OAAb,CAAqB,UAArB,EAAiCH,KAAjC;AACAjB,IAAAA,qBAAqB,CAACiB,KAAD,CAArB;AACAI,IAAAA,cAAc,CAACtB,SAAS,CAACkB,KAAD,CAAV,CAAd;AACAJ,IAAAA,OAAO,CAACC,GAAR,CAAYK,YAAY,CAACG,OAAb,CAAqB,UAArB,CAAZ;AAEA,QAAMd,KAAK,GAAGI,GAAG,CAACG,IAAJ,CAASA,IAAT,CAAcQ,QAAd,CAAuBf,KAArC;AACA,QAAMgB,IAAI,GAAGZ,GAAG,CAACG,IAAJ,CAASA,IAAT,CAAcQ,QAAd,CAAuBC,IAApC;AACA,QAAMC,MAAM,GAAGb,GAAG,CAACG,IAAJ,CAASA,IAAT,CAAcQ,QAAd,CAAuBG,OAAtC;AACA,QAAMC,SAAS,GAAGf,GAAG,CAACG,IAAJ,CAASA,IAAT,CAAcQ,QAAd,CAAuBK,WAAzC;AAEAT,IAAAA,YAAY,CAACC,OAAb,CAAqB,OAArB,EAA8BZ,KAA9B;AACAW,IAAAA,YAAY,CAACC,OAAb,CAAqB,MAArB,EAA6BI,IAA7B;AACAL,IAAAA,YAAY,CAACC,OAAb,CAAqB,QAArB,EAA+BK,MAA/B;AACAN,IAAAA,YAAY,CAACC,OAAb,CAAqB,WAArB,EAAkCO,SAAlC;AACD,GAtBM,CAAP;AAuBD;AACD,OAAO,SAASN,cAAT,CAAwBQ,IAAxB,EAA8B;AACnC,SAAO;AACLC,IAAAA,IAAI,EAAE7B,gBADD;AAEL4B,IAAAA,IAAI,EAAJA;AAFK,GAAP;AAID;AACD,OAAO,SAASE,MAAT,GAAkB;AACvB,SAAO,UAAAC,QAAQ,EAAI;AACjBb,IAAAA,YAAY,CAACc,UAAb,CAAwB,UAAxB;AACAjC,IAAAA,qBAAqB,CAAC,KAAD,CAArB;AACAqB,IAAAA,cAAc,CAAC,EAAD,CAAd;AACD,GAJD;AAKD,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import axios from \"axios\";\nimport jwtDecode from \"jwt-decode\";\nimport setAuthorizationToken from \"../utils/setAuthorizationToken\";\nimport { SET_CURRENT_USER } from \"../helpers/types\";\n\n/*Axios instance를 통해 config 객체를 넘겨서  Axios instance를 넘기면\n헤더를 중복하여 정의해주지 않아도 된다.*/\nconst signInAxios = axios.create({\n  baseURL: \"https://a.chameleon4switch.cf/api\",\n  headers: {\n    \"Content-Type\": \"application/json\"\n  },\n  timeout: 5000\n});\nexport function signIn(email, password) {\n  return signInAxios.post(\"auth/signIn\", { email, password }).then(res => {\n    console.log(res.data);\n\n    console.log(\"***************************\");\n    console.log(res.data.message);\n    console.log(\"***************************\");\n\n    const token = res.data.data.accessToken.token;\n    localStorage.setItem(\"jwtToken\", token);\n    setAuthorizationToken(token);\n    setCurrentUser(jwtDecode(token));\n    console.log(localStorage.getItem(\"jwtToken\"));\n\n    const email = res.data.data.userInfo.email;\n    const name = res.data.data.userInfo.name;\n    const nameEn = res.data.data.userInfo.name_en;\n    const profilImg = res.data.data.userInfo.profile_img;\n\n    localStorage.setItem(\"email\", email);\n    localStorage.setItem(\"name\", name);\n    localStorage.setItem(\"nameEn\", nameEn);\n    localStorage.setItem(\"profilImg\", profilImg);\n  });\n}\nexport function setCurrentUser(user) {\n  return {\n    type: SET_CURRENT_USER,\n    user\n  };\n}\nexport function logout() {\n  return dispatch => {\n    localStorage.removeItem(\"jwtToken\");\n    setAuthorizationToken(false);\n    setCurrentUser({});\n  };\n}\n\n// signInAxios.interceptors.response.use(\n//   function(response) {\n//     // If the request succeeds, we don't have to do anything and just return the response\n//     return response;\n//   },\n//   function(error) {\n//     const errorResponse = error.response;\n//     if (isTokenExpiredError(errorResponse)) {\n//       return resetTokenAndReattemptRequest(error);\n//     }\n//     // If the error is due to other reasons, we just throw it back to axios\n//     return Promise.reject(error);\n//   }\n// );\n// function isTokenExpiredError(errorResponse) {\n//   // Your own logic to determine if the error is due to JWT token expired returns a boolean value\n// }\n// let isAlreadyFetchingAccessToken = false;\n\n// // This is the list of waiting requests that will retry after the JWT refresh complete\n// let subscribers = [];\n\n// function resetTokenAndReattemptRequest(error) {\n//   try {\n//     const { response: errorResponse } = error;\n//     const resetToken = await TokenUtils.getResetToken(); // Your own mechanism to get the refresh token to refresh the JWT token\n//     if (!resetToken) {\n//       // We can't refresh, throw the error anyway\n//       return Promise.reject(error);\n//     }\n//     /* Proceed to the token refresh procedure\n//     We create a new Promise that will retry the request,\n//     clone all the request configuration from the failed\n//     request in the error object. */\n//     const retryOriginalRequest = new Promise(resolve => {\n//     /* We need to add the request retry to the queue\n//     since there another request that already attempt to\n//     refresh the token */\n//       addSubscriber(access_token => {\n//         errorResponse.config.headers.Authorization = 'Bearer ' + access_token;\n//         resolve(axios(errorResponse.config));\n//       });\n//     });\n//     if (!isAlreadyFetchingAccessToken) {\n//       isAlreadyFetchingAccessToken = true;\n//       const response = await axios({\n//         method: 'post',\n//         url: `<YOUR TOKEN REFREH ENDPOINT>`,\n//         data: {\n//           token: resetToken // Just an example, your case may vary\n//         }\n//       });\n//       if (!response.data) {\n//         return Promise.reject(error);\n//       }\n//       const newToken = response.data.token;\n//       TokenUtils.saveRefreshToken(newToken); // save the newly refreshed token for other requests to use\n//       isAlreadyFetchingAccessToken = false;\n//       onAccessTokenFetched(newToken);\n//     }\n//     return retryOriginalRequest;\n//   } catch (err) {\n//     return Promise.reject(err);\n//   }\n// }\n\n// function onAccessTokenFetched(access_token) {\n// \t// When the refresh is successful, we start retrying the requests one by one and empty the queue\n//   subscribers.forEach(callback => callback(access_token));\n//   subscribers = [];\n// }\n\n// function addSubscriber(callback) {\n//   subscribers.push(callback);\n// }\n\n// /////////////\n\n// export const login = (email, password) => {\n//   signInAxios\n//     .post(`/auth/signin`, { email, password })\n//     .then(res => {\n//       dispatch(loginSuccess(res.data, email));\n//       const token = res.data.token;\n//       axios.defaults.headers.common[\"Authorization\"] = token;\n//       history.pushState(\"/\");\n//     })\n//     .catch(err => {\n//       if (err.response.status === 401) {\n//         dispatch(loginFailure(err));\n//       }\n//     });\n// };\n"]},"metadata":{},"sourceType":"module"}